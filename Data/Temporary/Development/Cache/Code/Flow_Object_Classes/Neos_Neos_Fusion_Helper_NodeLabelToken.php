<?php 
namespace Neos\Neos\Fusion\Helper;

/*
 * This file is part of the Neos.Neos package.
 *
 * (c) Contributors of the Neos Project - www.neos.io
 *
 * This package is Open Source Software. For the full copyright and license
 * information, please view the LICENSE file which was distributed with this
 * source code.
 */

use Neos\ContentRepository\Domain\Model\NodeInterface;
use Neos\Eel\Helper\StringHelper;
use Neos\Eel\ProtectedContextAwareInterface;
use Neos\Flow\Annotations as Flow;
use Neos\Flow\I18n\EelHelper\TranslationHelper;

/**
 * Provides a chainable interface to build a label for a nodetype
 * with a fallback mechanism.
 */
class NodeLabelToken_Original implements ProtectedContextAwareInterface
{

    /**
     * @Flow\Inject
     * @var TranslationHelper
     */
    protected $translationHelper;

    /**
     * @Flow\Inject
     * @var StringHelper
     */
    protected $stringHelper;

    /**
     * @var string
     */
    protected $label = '';

    /**
     * @var int
     */
    protected $length = 100;

    /**
     * @var string
     */
    protected $suffix = '…';

    /**
     * @var string
     */
    protected $prefix = '';

    /**
     * @var string
     */
    protected $postfix = '';

    /**
     * @var NodeInterface
     */
    protected $node = null;

    public function __construct(NodeInterface $node)
    {
        $this->node = $node;
    }

    public function override(string $override = null): NodeLabelToken
    {
        if (empty($this->label) && $override) {
            $this->label = $override;
        }
        return $this;
    }

    public function crop(int $length, string $suffix = '...'): NodeLabelToken
    {
        $this->length = $length;
        $this->suffix = $suffix;
        return $this;
    }

    /**
     * Add a text before the main label
     */
    public function prefix(string $prefix): NodeLabelToken
    {
        $this->prefix = $prefix;
        return $this;
    }

    /**
     * Add a text after the main label (can will be cropped)
     */
    public function postfix(string $postfix): NodeLabelToken
    {
        $this->postfix = $postfix;
        return $this;
    }

    public function properties(string ...$propertyNames): NodeLabelToken
    {
        foreach ($propertyNames as $propertyName) {
            if ($this->node->hasProperty($propertyName) && !empty($this->node->getProperty($propertyName))) {
                $this->label = $this->node->getProperty($propertyName);
                break;
            }
        }
        return $this;
    }

    /**
     * Runs evaluate to avoid the need of calling evaluate as a finishing method
     */
    public function __toString(): string
    {
        return $this->evaluate();
    }

    /**
     * Crops, removes special chars & tags and trim the label.
     * If the label is empty a fallback based on the nodetype is provided.
     */
    public function evaluate(): string
    {
        if (empty($this->label)) {
            $this->resolveLabelFromNodeType();
        }

        return $this->sanitiseLabel($this->prefix . $this->label . $this->postfix);
    }

    /**
     * Sets the label and postfix based on the nodetype
     */
    protected function resolveLabelFromNodeType(): void
    {
        $this->label = $this->translationHelper->translate($this->node->getNodeType()->getLabel());
        if (empty($this->label)) {
            $this->label = $this->node->getNodeType()->getName();
        }
        if (empty($this->postfix) && $this->node->isAutoCreated()) {
            $this->postfix =  ' (' . $this->node->getName() . ')';
        }
    }

    protected function sanitiseLabel(string $label): string
    {
        $label = preg_replace('/<br\\W*?\\/?>|\\x{00a0}|[^[:print:]]|\\s+/u', ' ', $label);
        $label = strip_tags($label);
        $label = trim($label);
        $label = $this->stringHelper->cropAtWord($label, $this->length, $this->suffix);
        return $label;
    }

    /**
     * All methods are considered safe
     *
     * @param string $methodName
     * @return boolean
     */
    public function allowsCallOfMethod($methodName): bool
    {
        return true;
    }
}

#
# Start of Flow generated Proxy code
#
/**
 * Provides a chainable interface to build a label for a nodetype
 * with a fallback mechanism.
 * @codeCoverageIgnore
 */
class NodeLabelToken extends NodeLabelToken_Original implements \Neos\Flow\ObjectManagement\Proxy\ProxyInterface {

    use \Neos\Flow\ObjectManagement\Proxy\ObjectSerializationTrait, \Neos\Flow\ObjectManagement\DependencyInjection\PropertyInjectionTrait;


    /**
     * Autogenerated Proxy Method
     */
    public function __construct()
    {
        $arguments = func_get_args();

        if (!array_key_exists(0, $arguments)) $arguments[0] = \Neos\Flow\Core\Bootstrap::$staticObjectManager->get('Neos\ContentRepository\Domain\Model\NodeInterface');
        if (!array_key_exists(0, $arguments)) throw new \Neos\Flow\ObjectManagement\Exception\UnresolvedDependenciesException('Missing required constructor argument $node in class ' . __CLASS__ . '. Note that constructor injection is only support for objects of scope singleton (and this is not a singleton) – for other scopes you must pass each required argument to the constructor yourself.', 1296143788);
        parent::__construct(...$arguments);
        if ('Neos\Neos\Fusion\Helper\NodeLabelToken' === get_class($this)) {
            $this->Flow_Proxy_injectProperties();
        }
    }

    /**
     * Autogenerated Proxy Method
     */
    public function __sleep()
    {
            $result = NULL;
        $this->Flow_Object_PropertiesToSerialize = array();
        unset($this->Flow_Persistence_RelatedEntities);

        $transientProperties = array (
);
        $propertyVarTags = array (
  'translationHelper' => 'Neos\\Flow\\I18n\\EelHelper\\TranslationHelper',
  'stringHelper' => 'Neos\\Eel\\Helper\\StringHelper',
  'label' => 'string',
  'length' => 'integer',
  'suffix' => 'string',
  'prefix' => 'string',
  'postfix' => 'string',
  'node' => 'Neos\\ContentRepository\\Domain\\Model\\NodeInterface',
);
        $result = $this->Flow_serializeRelatedEntities($transientProperties, $propertyVarTags);
        return $result;
    }

    /**
     * Autogenerated Proxy Method
     */
    public function __wakeup()
    {

        $this->Flow_setRelatedEntities();
        $this->Flow_Proxy_injectProperties();
    }

    /**
     * Autogenerated Proxy Method
     */
    private function Flow_Proxy_injectProperties()
    {
        $this->translationHelper = new \Neos\Flow\I18n\EelHelper\TranslationHelper();
        $this->stringHelper = new \Neos\Eel\Helper\StringHelper();
        $this->Flow_Injected_Properties = array (
  0 => 'translationHelper',
  1 => 'stringHelper',
);
    }
}
# PathAndFilename: /Applications/MAMP/htdocs/neos-example/Packages/Application/Neos.Neos/Classes/Fusion/Helper/NodeLabelToken.php
#